<?php
namespace Modules\Hotel\Controllers;

use Carbon\Carbon;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Modules\Booking\Models\Booking;
use Modules\FrontendController;
use Modules\Hotel\Models\Hotel;
use Modules\Hotel\Models\HotelRoom;
use Modules\Hotel\Models\HotelRoomBooking;
use Modules\Hotel\Models\HotelRoomDate;
use Modules\Hotel\Services\AddDataInView;

class AvailabilityController extends FrontendController{

    protected $roomClass;
    /**
     * @var HotelRoomDate
     */
    protected $roomDateClass;

    /**
     * @var Booking
     */
    protected $bookingClass;
    protected $hotelClass;
    protected $currentHotel;
    protected $roomBookingClass;

    protected ?AddDataInView $cabinetService;

    protected $indexView = 'Hotel::frontend.user.availability';

    public function __construct(AddDataInView $cabinetService)
    {
        parent::__construct();
        $this->roomClass = HotelRoom::class;
        $this->roomDateClass = HotelRoomDate::class;
        $this->bookingClass = Booking::class;
        $this->hotelClass = Hotel::class;
        $this->roomBookingClass = HotelRoomBooking::class;
        $this->cabinetService = $cabinetService;
    }
    public function callAction($method, $parameters)
    {
        if(!Hotel::isEnable())
        {
            return redirect('/');
        }
        return parent::callAction($method, $parameters); // TODO: Change the autogenerated stub
    }

    protected function hasHotelPermission($hotel_id = false){
        if(empty($hotel_id)) return false;

        $hotel = $this->hotelClass::find($hotel_id);
        if(empty($hotel)) return false;

        if(!$this->hasPermission('hotel_update') and $hotel->author_id != Auth::id()){
            return false;
        }

        $this->currentHotel = $hotel;
        return true;
    }

    public function index(Request $request,$hotel_id)
    {
        $this->checkPermission('hotel_update');
        $user = $this->cabinetService->getViewUser();
        $viewAdminCabinet = $this->cabinetService->getCabinetData();

        if(!$this->hasHotelPermission($hotel_id))
        {
            abort(403);
        }

        $q = $this->roomClass::query();

        if($request->query('s')){
            $q->where('title','like','%'.$request->query('s').'%');
        }

        $q->orderBy('id','desc');
        $q->where('parent_id',$hotel_id);

        $rows = $q->paginate(15);

        $current_month = strtotime(date('Y-m-01',time()));

        if($request->query('month')){
            $date = date_create_from_format('m-Y',$request->query('month'));
            if(!$date){
                $current_month = time();
            }else{
                $current_month = $date->getTimestamp();
            }
        }
        $breadcrumbs = [
            [
                'name' => __('Hotels'),
                'url'  => route('hotel.vendor.index')
            ],
            [
                'name' => __('Hotel::name',['name'=>$this->currentHotel->title]),
                'url'  => route('hotel.vendor.edit',[$this->currentHotel->id])
            ],
            [
                'name'  => __('Availability'),
                'class' => 'active'
            ],
        ];
        $hotel = $this->currentHotel;
        $page_title = __('Room Availability');

        return view($this->indexView,compact('rows','breadcrumbs','current_month','page_title','request','hotel', 'user', 'viewAdminCabinet'));
    }

//
//    public function loadDates(Request $request, $hotel_id)
//    {
//        $request->validate([
//            'id' => 'required',
//            'start' => 'required',
//            'end' => 'required',
//        ]);
//
//        if (!$this->hasHotelPermission($hotel_id)) {
//            return $this->sendError(__("Hotel not found"));
//        }
//
//        $room = $this->roomClass::find($request->query('id'));
//        if (!$room) {
//            return $this->sendError(__('room not found'));
//        }
//
//        $is_single = $request->query('for_single');
//
//        /** ----------------------------------------
//         * 1. Загружаем кастомные даты
//         * ---------------------------------------- */
//        $rows = $this->roomDateClass::query()
//            ->where('target_id', $room->id)
//            ->whereBetween('start_date', [
//                date('Y-m-d 00:00:00', strtotime($request->query('start'))),
//                date('Y-m-d 23:59:59', strtotime($request->query('end')))
//            ])
//            ->get()
//            ->keyBy(fn ($row) => date('Y-m-d', strtotime($row->start_date)));
//
//        /** ----------------------------------------
//         * 2. Генерируем ВСЕ дни периода
//         * ---------------------------------------- */
//        $allDates = [];
//        $period = periodDate($request->input('start'), $request->input('end'), false);
//
//        foreach ($period as $dt) {
//            $dateKey = $dt->format('Y-m-d');
//
//            $allDates[$dateKey] = [
//                'id' => uniqid(),
//                'start' => $dateKey,
//                'allDay' => true,
//
//                'price' => $room->price,
//                'number' => $room->number,
//                'active' => 1,
//                'extendedProps' => [
//                    'max_number' => $room->number,
//                ],
//            ];
//
//            $priceHtml = format_money($room->price);
//            if (!$is_single) {
//                $priceHtml = format_money_main($room->price);
//            }
//
//            $allDates[$dateKey]['title'] = $priceHtml . ' x ' . $room->number;
//        }
//
//        /** ----------------------------------------
//         * 3. Мержим кастомные даты (НЕ затирая extendedProps)
//         * ---------------------------------------- */
//        foreach ($rows as $dateKey => $row) {
//            $price = $row->price ?: $room->price;
//            // Если number явно установлен (включая 0), используем его, иначе базовое значение
//            $number = ($row->number !== null) ? (int)$row->number : $room->number;
//
//            $existing = $allDates[$dateKey];
//
//            // Определяем, изменилась ли цена или количество
//            // Только для активных дней (не заблокированных)
//            $isActive = (int) $row->active;
//            $priceChanged = false;
//            $numberChanged = false;
//
//            if ($isActive) {
//                // Цена изменена, если явно установлена и отличается от базовой
//                $priceChanged = $row->price !== null && abs((float)$row->price - (float)$room->price) > 0.01;
//                // Количество изменено, если явно установлено и отличается от базового
//                $numberChanged = $row->number !== null && (int)$row->number != (int)$room->number;
//            }
//
//            // Определяем title в зависимости от статуса
//            $title = '';
//            if (!$isActive) {
//                // День заблокирован
//                $title = __('Blocked');
//            } elseif ($number == 0) {
//                // Нет номеров (полная бронь)
//                $title = __('Full Books');
//            } else {
//                // Обычный день с доступными номерами
//                $title = format_money_main($price) . ' x ' . $number;
//            }
//
//            $allDates[$dateKey] = array_merge(
//                $existing,
//                [
//                    'price' => $price,
//                    'number' => $number,
//                    'active' => $isActive,
//                    'classNames' => $isActive ? ['available-event'] : ['blocked-event'],
//                    'title' => $title,
//                ],
//                [
//                    'extendedProps' => array_merge(
//                        $existing['extendedProps'],
//                        [
//                            'max_number' => $room->number,
//                            'price_changed' => $priceChanged,
//                            'number_changed' => $numberChanged,
//                        ]
//                    ),
//                ]
//            );
//        }
//
//        /** ----------------------------------------
//         * 4. Учитываем бронирования
//         * ---------------------------------------- */
//        $bookings = $room->getBookingsInRange(
//            $request->query('start'),
//            $request->query('end')
//        );
//
//        foreach ($bookings as $roomBooking) {
//            $booking = Booking::find($roomBooking->booking_id);
//            if (!$booking) continue;
//
//            $period = periodDate(
//                $roomBooking->start_date,
//                Carbon::parse($roomBooking->end_date)->subDay(),
//                false
//            );
//
//
//            foreach ($period as $dt) {
//                $dateKey = $dt->format('Y-m-d');
//                if (!isset($allDates[$dateKey])) continue;
//
//                $day = &$allDates[$dateKey];
//
//                $day['bookings'][] = [
//                    'id' => $booking->id,
//                    'code' => $booking->code,
//                    'status' => $booking->status,
//                    'statusName' => $booking->statusName,
//                ];
//
//                // Используем количество забронированных номеров из roomBooking, а не количество гостей
//                $bookedRooms = (int)($roomBooking->number ?? 0);
//                $day['occupiedRooms'] = ($day['occupiedRooms'] ?? 0) + $bookedRooms;
//
//                // Используем базовое количество из кастомной даты или базовое количество номера
////                $baseNumber = $day['number'] ?? $room->number;
//                $baseNumber = $day['extendedProps']['max_number'];
//
//                // Вычисляем количество свободных номеров
//                $freeRooms = max($baseNumber - ($day['occupiedRooms'] ?? 0), 0);
//
//                if ($freeRooms <= 0) {
//                    // Полное бронирование - нет свободных номеров
//                    $day['active'] = 1; // Оставляем active = 1, чтобы отличать от заблокированного
//                    $day['number'] = 0;
//                    $day['classNames'] = ['full-book-event'];
//                    $day['title'] = __('Full Books');
//                } else {
//                    // Есть свободные номера
//                    $day['active'] = 1;
//                    $day['number'] = $freeRooms;
//                    $day['classNames'] = ['available-event'];
//                    $day['title'] = format_money_main($day['price']) . ' x ' . $day['number'];
//                }
//            }
//        }
//
//        /** ----------------------------------------
//         * 5. HTML для броней
//         * ---------------------------------------- */
//        foreach ($allDates as &$day) {
//            if (empty($day['bookings'])) { continue; }
//            $bookingHtml = '<div class="calendar-bookings">';
//            foreach ($day['bookings'] as $b) {
//                $status = htmlspecialchars($b['status'] ?? '');
//                $code = htmlspecialchars($b['code'] ?? '');
//                $label = htmlspecialchars($b['statusName'] ?? '');
//                $bookingHtml
//                    .= '<div class="booking-item booking-status-' . $status . '">'
//                    . '<span class="booking-id" data-id="' . (int)$b['id'] . '" data-code="' . e($b['code']) . '">'
//                    . 'Б' . (int)$b['id'] .
//                    '</span>'
//                    . '<span class="booking-status">' . $label . '</span>' . '</div>'; }
//
//            $bookingHtml .= '</div>';
//            $day['bookings_html'] = $bookingHtml;
//        }
//        unset($day);
//
//        return response()->json(array_values($allDates));
//    }

    public function loadDates(Request $request, $hotel_id)
    {
        $request->validate([
            'id' => 'required',
            'start' => 'required',
            'end' => 'required',
        ]);

        if (!$this->hasHotelPermission($hotel_id)) {
            return $this->sendError(__("Hotel not found"));
        }

        $room = $this->roomClass::find($request->query('id'));
        if (!$room) {
            return $this->sendError(__('room not found'));
        }

        $is_single = $request->query('for_single');

        /** ----------------------------------------
         * 1. Загружаем кастомные даты
         * ---------------------------------------- */
        $rows = $this->roomDateClass::query()
            ->where('target_id', $room->id)
            ->whereBetween('start_date', [
                date('Y-m-d 00:00:00', strtotime($request->query('start'))),
                date('Y-m-d 23:59:59', strtotime($request->query('end')))
            ])
            ->get()
            ->keyBy(fn ($row) => date('Y-m-d', strtotime($row->start_date)));

        /** ----------------------------------------
         * 2. Генерируем ВСЕ дни периода
         * ---------------------------------------- */
        $allDates = [];
        $period = periodDate($request->input('start'), $request->input('end'), false);

        foreach ($period as $dt) {
            $dateKey = $dt->format('Y-m-d');

            $allDates[$dateKey] = [
                'id' => uniqid(),
                'start' => $dateKey,
                'allDay' => true,

                'price' => $room->price,
                'number' => $room->number,
                'active' => 1,
                'extendedProps' => [
                    'max_number' => $room->number,
                ],
            ];

            $priceHtml = format_money($room->price);
            if (!$is_single) {
                $priceHtml = format_money_main($room->price);
            }

            $allDates[$dateKey]['title'] = $priceHtml . ' x ' . $room->number;
        }

        /** ----------------------------------------
         * 3. Мержим кастомные даты (НЕ затирая extendedProps)
         * ---------------------------------------- */
        foreach ($rows as $dateKey => $row) {
            $price = $row->price ?: $room->price;
            $number = ($row->number !== null) ? (int)$row->number : $room->number;

            $existing = $allDates[$dateKey];

            $isActive = (int) $row->active;
            $priceChanged = false;
            $numberChanged = false;

            if ($isActive) {
                $priceChanged = $row->price !== null && abs((float)$row->price - (float)$room->price) > 0.01;
                $numberChanged = $row->number !== null && (int)$row->number != (int)$room->number;
            }

            $title = '';
            if (!$isActive) {
                $title = __('Blocked');
            } elseif ($number == 0) {
                $title = __('Full Books');
            } else {
                $title = format_money_main($price) . ' x ' . $number;
            }

            $allDates[$dateKey] = array_merge(
                $existing,
                [
                    'price' => $price,
                    'number' => $number,
                    'active' => $isActive,
                    'classNames' => $isActive ? ['available-event'] : ['blocked-event'],
                    'title' => $title,
                ],
                [
                    'extendedProps' => array_merge(
                        $existing['extendedProps'],
                        [
                            'max_number' => $room->number,
                            'price_changed' => $priceChanged,
                            'number_changed' => $numberChanged,
                        ]
                    ),
                ]
            );
        }

        /** ----------------------------------------
         * 4. Учитываем бронирования с учётом дня выезда
         * ---------------------------------------- */
        $bookings = $room->getBookingsInRange(
            $request->query('start'),
            $request->query('end')
        );

        foreach ($bookings as $roomBooking) {
            $booking = Booking::find($roomBooking->booking_id);
            if (!$booking) continue;

            // -------------------------------
            // ИЗМЕНЕНИЕ: включаем день выезда в период для отображения
            // раньше был ->subDay(), теперь полный диапазон
            $period = periodDate(
                $roomBooking->start_date,
                $roomBooking->end_date,
                false
            );

            $endDate = Carbon::parse($roomBooking->end_date)->format('Y-m-d');

            foreach ($period as $dt) {
                $dateKey = $dt->format('Y-m-d');
                if (!isset($allDates[$dateKey])) continue;

                $day = &$allDates[$dateKey];

                // Добавляем бронь в массив
                $day['bookings'][] = [
                    'id' => $booking->id,
                    'code' => $booking->code,
                    'status' => $booking->status,
                    'statusName' => $booking->statusName,
                ];

                // -------------------------------
                // ИЗМЕНЕНИЕ: расчет свободных комнат только если день не день выезда
                if ($dateKey !== $endDate) {
                    $bookedRooms = (int)($roomBooking->number ?? 0);
                    $day['occupiedRooms'] = ($day['occupiedRooms'] ?? 0) + $bookedRooms;

                    $baseNumber = $day['extendedProps']['max_number'];
                    $freeRooms = max($baseNumber - ($day['occupiedRooms'] ?? 0), 0);

                    if ($freeRooms <= 0) {
                        $day['active'] = 1;
                        $day['number'] = 0;
                        $day['classNames'] = ['full-book-event'];
                        $day['title'] = __('Full Books');
                    } else {
                        $day['active'] = 1;
                        $day['number'] = $freeRooms;
                        $day['classNames'] = ['available-event'];
                        $day['title'] = format_money_main($day['price']) . ' x ' . $day['number'];
                    }
                } else {
                    $day['classNames'] = ['checkout-day-event'];
                    $day['title'] = format_money_main($day['price']) . ' x ' . $day['number'];
                }
            }
        }

        /** ----------------------------------------
         * 5. HTML для броней
         * ---------------------------------------- */
        foreach ($allDates as &$day) {
            if (empty($day['bookings'])) { continue; }
            $bookingHtml = '<div class="calendar-bookings">';
            foreach ($day['bookings'] as $b) {
                $status = htmlspecialchars($b['status'] ?? '');
                $code = htmlspecialchars($b['code'] ?? '');
                $label = htmlspecialchars($b['statusName'] ?? '');

                // Проверяем, день выезда ли это для этой брони
                $isCheckout = false;
                $bookingModel = Booking::find($b['id']);
                if ($bookingModel) {
                    $endDate = Carbon::parse($bookingModel->end_date)->format('Y-m-d');
                    if ($endDate === $day['start']) {
                        $isCheckout = true;
                    }
                }

                $bookingHtml .= '<div class="booking-item booking-status-' . $status . '">'
                    . '<span class="booking-id" data-id="' . (int)$b['id'] . '" data-code="' . e($b['code']) . '">'
                    . 'Б' . (int)$b['id'] .
                    '</span>'
                    . '<span class="booking-status">' . $label . '</span>';

                // Добавляем (Выезд) только рядом с этой бронью
                if ($isCheckout) {
                    $bookingHtml .= ' <span class="checkout-label">(В)</span>';
                }

                $bookingHtml .= '</div>';
            }

            $bookingHtml .= '</div>';
            $day['bookings_html'] = $bookingHtml;
        }
        unset($day);


        return response()->json(array_values($allDates));
    }


    public function store(Request $request,$hotel_id)
    {
        if(!$this->hasHotelPermission($hotel_id))
        {
            return $this->sendError(__("Hotel not found"));
        }

        $request->validate([
            'target_id'=>'required',
            'start_date'=>'required',
            'end_date'=>'required'
        ]);

        $room = $this->roomClass::find($request->input('target_id'));
        $target_id = $request->input('target_id');

        if(empty($room)){
            return $this->sendError(__('Room not found'));
        }

        if(!$this->hasPermission('hotel_manage_others')){

            if($this->currentHotel->author_id != Auth::id()){
                return $this->sendError("You do not have permission to access it");
            }
        }

        $dayOfWeek =$request->input("day_of_week_select",[]);

        $postData = $request->input();
        $period = periodDate($request->input('start_date'),$request->input('end_date'));
        foreach ($period as $dt){
            $date = $this->roomDateClass::where('start_date',$dt->format('Y-m-d'))->where('target_id',$target_id)->first();

            if(empty($date)){
                $date = new $this->roomDateClass();
                $date->target_id = $target_id;
            }
            $postData['start_date'] = $dt->format('Y-m-d H:i:s');
            $postData['end_date'] = $dt->format('Y-m-d H:i:s');

            // Убеждаемся, что number передается, даже если это 0
            if (!isset($postData['number'])) {
                $postData['number'] = $room->number;
            }
            // Преобразуем в int, чтобы 0 не считался пустым
            $postData['number'] = (int)($postData['number'] ?? $room->number);

            $date->fillByAttr([
                'start_date','end_date','price',
                'is_instant','active',
                'number'
            ],$postData);

            if(empty($dayOfWeek)){
                $date->save();
            }elseif(in_array(date('N', strtotime($dt->format('Y-m-d H:i:s')) ),$dayOfWeek)){
                $date->save();
            }
        }

        return $this->sendSuccess([],__("Update Success"));
    }
}
